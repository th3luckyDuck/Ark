<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Ark — Open-roof 3-piece tunnel, centered HUD, full functionality</title>

    <!-- A-Frame core -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>

    <style>
      html, body { margin:0; padding:0; background:#000; }
      canvas { outline: none; }
    </style>

    <script>
      /* ===== Helpers ===== */
      const q  = s => document.querySelector(s);
      const qa = s => Array.from(document.querySelectorAll(s));
      const emit = (type, ids) => ids.forEach(id => q(id)?.emit(type, null, false));
      const play = id => { const e = q(id); if (e?.components?.sound) e.components.sound.playSound(); };
      const pause= id => { const e = q(id); if (e?.components?.sound) e.components.sound.pauseSound(); };
      const setText = (id, v) => q(id)?.setAttribute('text', `value: ${v}; color: #6FF3E8; width: 6; align: left`);
      const bindClick = (sel, cb) => { const el = q(sel); if (!el) return; el.classList.add('ui'); el.addEventListener('click', cb); };

      /* ===== Cursor whitelist for UI ===== */
      AFRAME.registerComponent('cursor-whitelist', {
        init() {
          this.el.setAttribute('cursor', 'rayOrigin: mouse; fuse: false');
          this.el.setAttribute('raycaster', 'objects: .ui');
        }
      });

      /* ===== HUD anchor: bottom-centered row, locked to camera ===== */
      AFRAME.registerComponent('hud-anchor', {
        schema: {
          distance: {type:'number', default: 2.2},   // in front of camera
          vertical: {type:'number', default: -0.9},  // near bottom of view
          scale:    {type:'number', default: 1.0}
        },
        tick() {
          const cam = this.el.sceneEl.camera?.el;
          if (!cam) return;
          const camObj = cam.object3D;

          const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camObj.quaternion).normalize();
          const pos = new THREE.Vector3().copy(camObj.position)
            .add(forward.multiplyScalar(this.data.distance))
            .add(new THREE.Vector3(0, this.data.vertical, 0));

          const o3 = this.el.object3D;
          o3.position.copy(pos);
          o3.quaternion.copy(camObj.quaternion);
          o3.rotateY(Math.PI);
          o3.scale.setScalar(this.data.scale);
        }
      });

      /* ===== Runner physics (lanes, jump, collisions) ===== */
      AFRAME.registerComponent('runner-physics', {
        schema: { gravity:{default:-9.8}, jumpVelocity:{default:6}, groundY:{default:0} },
        init() {
          this.velY = 0; this.grounded = true;
          this.targetLane = 1; // 0:-3, 1:0, 2:+3 on Z
          this.lanes = [-3,0,3];
          this.size = new THREE.Vector3(0.8,1.6,0.8);
          this.playerBox = new THREE.Box3();
          this.obstacles = [];
          this.refreshObstacles = () => { this.obstacles = qa('.obstacle'); };

          const p = this.el.object3D.position;
          p.set(0, this.data.groundY + this.size.y/2, 0);

          window.addEventListener('keydown', e => {
            const k = e.key;
            if (k==='ArrowLeft' || k==='a' || k==='A') this.targetLane = Math.max(0, this.targetLane-1);
            if (k==='ArrowRight'|| k==='d' || k==='D') this.targetLane = Math.min(2, this.targetLane+1);
            if (k===' ' || k==='Spacebar') this.jump();
          });
        },
        jump(){ if(this.grounded){ this.velY=this.data.jumpVelocity; this.grounded=false; emit('jump',['#jumpb']); } },
        tick(t,dt){
          const d=dt/1000; if(!d) return;
          const pos=this.el.object3D.position;

          // Lane snap (Z)
          const tz=this.lanes[this.targetLane];
          pos.z += (tz - pos.z) * Math.min(1, d*12);

          // Clamp Z to side walls (±10)
          pos.z = Math.max(-9.5, Math.min(9.5, pos.z));

          // Gravity
          this.velY += this.data.gravity*d;
          pos.y += this.velY*d;
          const groundY = this.data.groundY + this.size.y/2; // floor at y=0
          if(pos.y<=groundY){ pos.y=groundY; this.velY=0; this.grounded=true; }

          // Player AABB
          const half = new THREE.Vector3(this.size.x/2, this.size.y/2, this.size.z/2);
          const min = new THREE.Vector3().copy(pos).sub(half);
          const max = new THREE.Vector3().copy(pos).add(half);
          this.playerBox.min.copy(min); this.playerBox.max.copy(max);

          // Collisions with blocks: hard reset
          const obs = Array.isArray(this.obstacles) ? this.obstacles : [];
          for(const e of obs){
            const wp=new THREE.Vector3();
            e.object3D.getWorldPosition(wp);
            const geo=e.getAttribute('geometry')||{};
            const sx=geo.width||2, sy=geo.height||8, sz=geo.depth||4;
            const hb=new THREE.Vector3(sx/2,sy/2,sz/2);
            const box=new THREE.Box3(wp.clone().sub(hb), wp.clone().add(hb));
            if(this.playerBox.intersectsBox(box)){ hardReset(false); break; }
          }
        }
      });

      /* ===== Game state ===== */
      let timers = [];
      let intervals = [];
      let gameStarted = false;
      let startWired = false;
      let scoring = false;
      let score = 0;
      let lastscore=0,lastscore2=0,lastscore3=0,lastscore4=0,lastscore5=0;
      let boss = false;

      function clearTimers(){ timers.forEach(t=>clearTimeout(t)); timers=[]; }
      function clearIntervals(){ intervals.forEach(i=>clearInterval(i)); intervals=[]; }
      function clearObstacles(){ qa('.obstacle').forEach(e=>e.parentNode.removeChild(e)); q('#player')?.components?.['runner-physics']?.refreshObstacles(); }

      /* ===== Build tunnel (3-piece: floor + left wall + right wall; NO ROOF) ===== */
      function buildTunnel(){
        const scene=q('a-scene');
        let tunnel=q('#tunnel');
        if(!tunnel){ tunnel=document.createElement('a-entity'); tunnel.setAttribute('id','tunnel'); scene.appendChild(tunnel); }
        tunnel.innerHTML='';
        tunnel.setAttribute('position','0 0 0');

        // Three boxes, centered around the player, long in +X and -X
        const length = 2000;

        const mk = (pos, rot, scale, color) => {
          const e=document.createElement('a-box');
          e.setAttribute('position',pos);
          e.setAttribute('rotation',rot);
          e.setAttribute('scale',scale);
          e.setAttribute('material',`color:${color}; side: double`);
          return e;
        };

        // Floor: flat surface at y=0, extends length along X
        const floor = mk('0 0 0','-90 0 0',`${length} 10 10`,'#1f4959');

        // Side walls at z = ±10, tall enough for the run
        const left  = mk('0 15 -10','0 0 0', `${length} 30 1`,'#1f4959');
        const right = mk('0 15 10','0 0 0',  `${length} 30 1`,'#1f4959');

        tunnel.appendChild(floor);
        tunnel.appendChild(left);
        tunnel.appendChild(right);
      }

      /* ===== Blocks: fall then rush at player ===== */
      const colors = {1:'#ff0000', 2:'#a041f4', 3:'#f47c41', 4:'#4158f4', 5:'#0618a3'};

      function spawnBlock(level, lane) {
        const laneZ = [-3,0,3][lane];
        const scene = q('a-scene');
        const startX = 700;
        const fallH  = 35;

        const box = document.createElement('a-box');
        box.classList.add('obstacle');
        box.setAttribute('geometry', 'primitive: box; width: 2; height: 8; depth: 4');
        box.setAttribute('position', `${startX} ${fallH} ${laneZ}`);
        box.setAttribute('material', `color: ${colors[level]}; side: double; metalness:0; roughness:1`);

        box.setAttribute('animation__fall', {
          property: 'position',
          from: `${startX} ${fallH} ${laneZ}`,
          to:   `${startX} 2 ${laneZ}`,
          dur:  900,
          easing: 'easeOutCubic'
        });
        box.setAttribute('animation__rush', {
          property: 'position',
          from: `${startX} 2 ${laneZ}`,
          to:   `-80 2 ${laneZ}`,
          dur:  4800,
          delay:900,
          easing: 'linear'
        });

        scene.appendChild(box);
        q('#player')?.components?.['runner-physics']?.refreshObstacles();
      }

      function scheduleBlocks(level, secs=40, rateMs=1400){
        const start = Date.now();
        const iv = setInterval(()=>{
          if (!scoring){ clearInterval(iv); return; }
          const lane = Math.floor(Math.random()*3);
          spawnBlock(level, lane);
          if (Date.now() - start > secs*1000) { clearInterval(iv); }
        }, rateMs);
        intervals.push(iv);
      }

      /* ===== Music + gates ===== */
      function wireMusicAndGates(){
        if (startWired) return;
        startWired = true;

        const target=q('#target'); if(!target) return;

        target.addEventListener('start1', ()=>{
          ['#song2','#song3','#song4','#song5','#song6'].forEach(pause);
          play('#song');
          scoring=true;
          scheduleBlocks(1, 45, 1450);
          showCountdown();
        }, {once:true});

        target.addEventListener('start2', ()=>{
          play('#hah1');
          ['#song','#song2','#song4','#song5','#song6'].forEach(pause);
          play('#song3');
          scheduleBlocks(2, 45, 1400);
        }, {once:true});

        target.addEventListener('start3', ()=>{
          play('#hah2');
          ['#song','#song2','#song3','#song5','#song6'].forEach(pause);
          play('#song4');
          scheduleBlocks(3, 45, 1350);
        }, {once:true});

        target.addEventListener('start4', ()=>{
          play('#hah3');
          ['#song','#song2','#song3','#song4','#song6'].forEach(pause);
          play('#song5');
          scheduleBlocks(4, 45, 1300);
        }, {once:true});

        target.addEventListener('start5', ()=>{
          play('#hah1');
          ['#song','#song2','#song3','#song4','#song5'].forEach(pause);
          play('#song6');
          boss = true;
          scheduleBlocks(5, 60, 1200);

          const bossE = q('#boss');
          if (bossE){
            bossE.setAttribute('visible','true');
            bossE.setAttribute('position','800 -60 0');
            bossE.setAttribute('animation__rise','property: position; from: 800 -60 0; to: 450 0 0; dur: 2500; easing: easeOutCubic; startEvents: boss-rise');
            bossE.setAttribute('animation__approach','property: position; to: 300 0 0; dur: 3000; delay: 2500; easing: easeInOutCubic; startEvents: boss-approach');
            bossE.emit('boss-rise');
            bossE.emit('boss-approach');
          }

          setTimeout(()=>play('#hah1'),4500);
          setTimeout(()=>play('#hah2'),4500);
          setTimeout(()=>play('#hah3'),4500);
        }, {once:true});

        timers.push(setTimeout(()=>emit('start2',['#target']), 50000));
        timers.push(setTimeout(()=>emit('start3',['#target']),100000));
        timers.push(setTimeout(()=>emit('start4',['#target']),150000));
        timers.push(setTimeout(()=>emit('start5',['#target']),200000));
      }

      function showCountdown(){
        // Place countdown just in front of camera, centered, facing the player
        const camEl = q('#playerCam'); if (!camEl) return;
        const cam = camEl.object3D;
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(cam.quaternion).normalize();
        const basePos = new THREE.Vector3().copy(cam.position).add(forward.multiplyScalar(2)).add(new THREE.Vector3(0,0.9,0));

        const rotY = (new THREE.Euler().setFromQuaternion(cam.quaternion)).y + Math.PI;
        const rot = `0 ${THREE.MathUtils.radToDeg(rotY)} 0`;

        const three=q('#threeb'), two=q('#twob'), one=q('#oneb');
        if (three && two && one){
          three.setAttribute('position', `${basePos.x} ${basePos.y} ${basePos.z}`);
          two.setAttribute('position',   `0 -100 0`);
          one.setAttribute('position',   `0 -100 0`);
          three.setAttribute('rotation', rot); two.setAttribute('rotation', rot); one.setAttribute('rotation', rot);
          setTimeout(()=>{ three.setAttribute('position','0 -100 0'); two.setAttribute('position', `${basePos.x} ${basePos.y} ${basePos.z}`); },1000);
          setTimeout(()=>{ two.setAttribute('position','0 -100 0'); one.setAttribute('position', `${basePos.x} ${basePos.y} ${basePos.z}`); },2000);
          setTimeout(()=>{ one.setAttribute('position','0 -100 0'); },3000);
        }
      }

      /* ===== Reset / Lobby ===== */
      function hardReset(toLobby=false){
        clearTimers();
        clearIntervals();
        clearObstacles();
        boss=false;
        scoring=false;
        gameStarted=false;
        startWired=false;

        if (score>=50){ lastscore5=lastscore4; lastscore4=lastscore3; lastscore3=lastscore2; lastscore2=lastscore; lastscore=score; }
        setText('#lastscore', String(lastscore));
        setText('#lastscore2', String(lastscore2));
        setText('#lastscore3', String(lastscore3));
        setText('#lastscore4', String(lastscore4));
        setText('#lastscore5', String(lastscore5));
        score=0; setText('#scoreshow','0');

        const bossE = q('#boss'); if (bossE){ bossE.setAttribute('visible','false'); bossE.setAttribute('position','800 -60 0'); }

        ['#song','#song2','#song3','#song4','#song5','#song6','#hah1','#hah2','#hah3','#gameovers','#load'].forEach(pause);
        if (toLobby) play('#song2');

        buildTunnel();

        const p=q('#player'); if (p) {
          p.setAttribute('position','0 0.8 0');
          const cam = q('#playerCam');
          if (cam) {
            // Turn 90° to the right to face +X
            cam.object3D.rotation.set(0, THREE.MathUtils.degToRad(-90), 0);
          }
          const phys=p.components['runner-physics'];
          if (phys){ phys.targetLane=1; phys.velY=0; phys.refreshObstacles(); }
        }
      }

      /* ===== Boot ===== */
      document.addEventListener('DOMContentLoaded', ()=>{
        buildTunnel();

        // Audio unlock
        bindClick('#enterArk', ()=>{
          try{ if (AFRAME.audioContext?.state==='suspended') AFRAME.audioContext.resume(); }catch(e){}
          play('#song2'); play('#click');
        });

        // Start game: wire before emit, avoid double state setting
        bindClick('#startcc', ()=>{
          if (gameStarted) return;
          wireMusicAndGates();
          play('#begin3');
          emit('start1',['#target']);
          gameStarted=true;
        });

        // Lane buttons
        bindClick('#leftT',   ()=>{ const c=q('#player')?.components?.['runner-physics']; if(c){ c.targetLane=0; } });
        bindClick('#centerT', ()=>{ const c=q('#player')?.components?.['runner-physics']; if(c){ c.targetLane=1; } });
        bindClick('#rightT',  ()=>{ const c=q('#player')?.components?.['runner-physics']; if(c){ c.targetLane=2; } });

        // Jump
        bindClick('#jumpb', ()=>{ q('#player')?.components?.['runner-physics']?.jump(); });

        // Mute toggle (flip only volume; preserve attributes)
        bindClick('#songT', ()=>{
          const ids=['#song','#song2','#song3','#song4','#song5','#song6','#begin3','#gameovers','#lazer','#click','#click2','#hah1','#hah2','#hah3'];
          const muted = (q('#song').components?.sound?.data?.volume===0);
          ids.forEach(sel=>{
            const el=q(sel); if(!el?.components?.sound) return;
            const cfg = el.getAttribute('sound') || {};
            cfg.volume = muted ? (cfg.volume ?? 0.3) : 0;
            el.setAttribute('sound', cfg);
          });
        });

        // Lobby / join / reset
        bindClick('#lobbybtn', ()=>{ play('#click2'); hardReset(true); });
        bindClick('#joinsm',   ()=>{ play('#click2'); });
        bindClick('#joinh',    ()=>{ play('#click2'); });
        bindClick('#resetb',   ()=>{ hardReset(false); });

        // Scoring tick
        intervals.push(setInterval(()=>{ if (scoring){ score+=10; setText('#scoreshow', String(score)); } },2000));

        // Boss laugh loop
        intervals.push(setInterval(()=>{ if(boss) play('#hah1'); },25000));

        // Initialize obstacle list
        q('#player')?.components?.['runner-physics']?.refreshObstacles();

        // Ensure camera faces +X at start
        const cam=q('#playerCam');
        if (cam) { cam.object3D.rotation.set(0, THREE.MathUtils.degToRad(-90), 0); }
      });
    </script>
  </head>
  <body>
    <a-scene renderer="colorManagement: true; physicallyCorrectLights: true" background="color: #000">
      <a-assets>
        <!-- UI images -->
        <img id="leftp" src="left.jpg">
        <img id="centerp" src="center.jpg">
        <img id="rightp" src="right.jpg">
        <img id="jumpp" src="jump.jpg">
        <img id="mutep" src="mute.jpg">
        <img id="startp" src="start.jpg">
        <img id="resetp" src="reset.jpg">
        <img id="lobbyp" src="lobby.jpg">
        <img id="joinsmallp" src="joinsmall.jpg">
        <img id="joinp" src="join.jpg">
        <img id="p1" src="1.jpg">
        <img id="p2" src="2.jpg">
        <img id="p3" src="3.jpg">

        <!-- Boss OBJ -->
        <a-asset-item id="run-obj" src="run.obj"></a-asset-item>
      </a-assets>

      <!-- Lights: directional + ambient -->
      <a-light type="directional" intensity="1.4" position="150 25 15"></a-light>
      <a-light type="ambient" color="#ffffff" intensity="0.7"></a-light>

      <!-- Player anchored; camera 90° right to face +X; HUD locked as bottom row -->
      <a-entity id="player" position="0 0.8 0" runner-physics>
        <a-entity id="playerCam" camera look-controls cursor-whitelist>

          <!-- Attach audio to camera -->
          <a-entity id="audio-root">
            <a-entity id="song"   sound="src:url(arktheme.wav);   loop:true; autoplay:false; volume:0.2"></a-entity>
            <a-entity id="song2"  sound="src:url(arkpregame.wav); loop:true; autoplay:false; volume:0.2"></a-entity>
            <a-entity id="song3"  sound="src:url(arktheme2.wav);  loop:true; autoplay:false; volume:0.2"></a-entity>
            <a-entity id="song4"  sound="src:url(arktheme3.wav);  loop:true; autoplay:false; volume:0.2"></a-entity>
            <a-entity id="song5"  sound="src:url(arktheme4.wav);  loop:true; autoplay:false; volume:0.2"></a-entity>
            <a-entity id="song6"  sound="src:url(level5.wav);     loop:true; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="hah1" sound="src:url(ha1.wav); loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="hah2" sound="src:url(ha2.wav); loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="hah3" sound="src:url(ha3.wav); loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="begin3" sound="src:url(begin.wav); loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="gameovers" sound="src:url(gameover.wav); loop:false; autoplay:false; volume:1"></a-entity>
            <a-entity id="click"  sound="src:url(click.wav);  loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="click2" sound="src:url(click.wav);  loop:false; autoplay:false; volume:0.3"></a-entity>
            <a-entity id="lazer"  sound="src:url(lazer.wav);  loop:false; autoplay:false; volume:0.3"></a-entity>
          </a-entity>

          <!-- HUD: bottom-centered row -->
          <a-entity id="HUD" hud-anchor="distance: 2.2; vertical: -0.9; scale: 1">
            <a-entity id="hud-row" position="0 0 0">
              <!-- Left cluster -->
              <a-plane id="enterArk" width="0.6" height="0.18" material="color:#2c3e50; side: double" class="ui" position="-1.7 0 0"></a-plane>
              <a-entity text="value: Enter Ark; color:#fff; align:center; width:3" position="-1.7 0 0.01"></a-entity>
              <a-plane id="startcc" src="#startp" width="0.6" height="0.18" material="side: double" class="ui" position="-0.95 0 0"></a-plane>
              <a-plane id="songT"   src="#mutep"  width="0.45" height="0.18" material="side: double" class="ui" position="-0.40 0 0"></a-plane>

              <!-- Center cluster: lanes + jump -->
              <a-plane id="leftT"   src="#leftp"   width="0.28" height="0.18" material="side: double" class="ui" position="0.05 0 0"></a-plane>
              <a-plane id="centerT" src="#centerp" width="0.28" height="0.18" material="side: double" class="ui" position="0.40 0 0"></a-plane>
              <a-plane id="rightT"  src="#rightp"  width="0.28" height="0.18" material="side: double" class="ui" position="0.75 0 0"></a-plane>
              <a-plane id="jumpb"   src="#jumpp"   width="0.42" height="0.18" material="side: double" class="ui" position="1.20 0 0"></a-plane>

              <!-- Right cluster: lobby/join/reset -->
              <a-plane id="lobbybtn" src="#lobbyp"       width="0.55" height="0.18" material="side: double" class="ui" position="1.80 0 0"></a-plane>
              <a-plane id="joinsm"   src="#joinsmallp"   width="0.24" height="0.18" material="side: double" class="ui" position="2.20 0 0"></a-plane>
              <a-plane id="joinh"    src="#joinp"        width="0.55" height="0.18" material="side: double" class="ui" position="2.60 0 0"></a-plane>

              <!-- Score -->
              <a-entity id="scoreshow" text="value: 0; color: #6FF3E8; align: left; width: 6" position="3.15 0 0.01"></a-entity>
            </a-entity>
          </a-entity>
        </a-entity>
      </a-entity>

      <!-- Tunnel (3-piece, open roof) -->
      <a-entity id="tunnel"></a-entity>

      <!-- Countdown images -->
      <a-plane id="threeb" src="#p3" position="0 -100 0" width="1" height="1" material="side: double"></a-plane>
      <a-plane id="twob"   src="#p2" position="0 -100 0" width="1" height="1" material="side: double"></a-plane>
      <a-plane id="oneb"   src="#p1" position="0 -100 0" width="1" height="1" material="side: double"></a-plane>

      <!-- Boss -->
      <a-entity id="boss" position="800 -60 0" rotation="0 90 0" scale="50 50 50"
                obj-model="obj: #run-obj"
                material="color:#cccccc; side: double"
                visible="false"></a-entity>

      <!-- Target for gate events -->
      <a-entity id="target"></a-entity>

      <!-- Reset button (world fallback) -->
      <a-plane id="resetb" src="#resetp" width="0.7" height="0.2" position="13 0 0" rotation="0 -90 0" material="side: double" class="ui"></a-plane>

      <!-- Minimal score history -->
      <a-entity id="lastscore"  position="-14.8 2 0" rotation="0 90 0" text="value:0; color:#6FF3E8; width:6"></a-entity>
      <a-entity id="lastscore2" position="-14.8 1.5 0" rotation="0 90 0" text="value:0; color:#6FF3E8; width:6"></a-entity>
      <a-entity id="lastscore3" position="-14.8 1.0 0" rotation="0 90 0" text="value:0; color:#6FF3E8; width:6"></a-entity>
      <a-entity id="lastscore4" position="-14.8 0.5 0" rotation="0 90 0" text="value:0; color:#6FF3E8; width:6"></a-entity>
      <a-entity id="lastscore5" position="-14.8 0.0 0" rotation="0 90 0" text="value:0; color:#6FF3E8; width:6"></a-entity>

      <!-- Sky -->
      <a-sky color="black" radius="1050"></a-sky>
    </a-scene>
  </body>
</html>
